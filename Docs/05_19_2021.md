## 05/19/2021

Session 클래스의 Recieve, Send 메서드 비동기 처리

### `Receive(byte[] buffer)`
클라이언트로부터의 메시지를 기다림, 메시지가 없으면 무한정 대기함. (Blocking Method)

### `ReceiveAsync(SocketAsyncEventArgs e)`
일단 메시지를 받아본다. 받을 수 있는 메시지가 있어서 즉시 받을 수도 있다. (동기) 

그렇지 않고 메시지가 당장 없었다면 나중에 메시지가 올 때 메시지를 받고 다시 알려준다.

이 때 `e.Completed` 프로퍼티로 넣어준 함수가 실행된다.

클라이언트로부터 받은 메시지는 `e.Buffer`에 있다.


### `Send(byte[] buffer)`
`buffer`를 클라이언트로 보냄. 성공적으로 보낸 경우 클라이언트로 보낸 바이트 수를 정수형으로 반환함. `buffer`가 모두 보내질 때 까지 대기하며 받을 수 없는 상태라면 계속 대기한다.

### `SendAsync(SocketAsyncEventArgs e)`
`buffer`를 클라이언트로 비동기적으로 보냄.

이 메서드를 사용하는 이유를 간략하게 설명하자면,

`A`, `B`, `C`라는 각각의 메시지를 순차적으로 클라이언트에 보낸다고 하자.

메시지를 각각 동기적으로 보내주려고 하면, `A`가 모두 보내지기 전까지 대기해야 하며 이는 비효율을 야기한다.

그래서 `A`가 모두 보내질 때 까지 굳이 기다리지 않고, (다른 작업도 좀 하면서) `B`와 `C`도 각각 보내질 수 있게 하는 것이다.


---

### Receive와 Send의 차이점

Receive는 "무엇을" 처리하는가? : **클라이언트로부터의** 메시지 -> (요청)

Send는 "무엇을" 처리하는가? : 클라이언트로 **보낼** 메시지 -> (응답)

Receive를 호출할 때, 항상 요청이 있을 필요는 없다. Receive를 실행시켜두고, 요청이 들어오면 처리를 시작한다.

반면 Send가 다른 점은, 응답 메시지도 없이 Send를 호출하는 경우는 없다는 것이다.


### 비동기로 처리할 때의 차이점

식당으로 비유하자면,

* ReceiveAsync가 비동기로 처리되는 상황 : 대기 손님이 없는 경우. 일단 아무나 입장할 수 있도록 준비를 해둔 상태이고, 손님이 등장하면 바로 입장시킴. (`e.Completed` 호출)
* ReceiveAsync가 동기로 처리되는 상황 : 대기 손님이 있는(많은) 경우. 그냥 존재하는 손님을 바로 입장시킬 수 있음. 

* SendAsync가 비동기로 처리되는 상황 : 음식을 3개 시킨 손님이 있다. 첫 번째 음식 `A`가 나왔는데, 손님이 아직 테이블로 가져가지 못한 경우이다. 손님이 아직 테이블로 음식을 가져가지 못했다고 해서, `A`를 가져갈 때 까지 두 번째 음식 `B`를 내보내지 않고 기다릴 이유가 없으므로 `B`를 카운터에 놓여있는 `A`의 옆에 둔다. (`_sendQueue`에 Enqueue한다.)
* SendAsync가 동기로 처리되는 상황 : 음식을 3개 시킨 손님이 음식 `A`가 나온 즉시 곧바로 테이블로 가져가는 데 성공한 경우이다.

(사실 비유가 적절한 지 잘 모르겠다.)